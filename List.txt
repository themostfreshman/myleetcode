1.11 乘最多水的容器
	最开始的想法是 数组嘛，遍历就完事了，每个元素当key，判断当前key的最大值。。brute force
	双指针的核心是如何移动指针，也就是状态的剪枝，动谁呢，动小的那边，面积才有可能增大，
	s[i,j] 假设h[i]<h[j]，那么s[i+1,j] 一定大于s[i,j-1]、s[i,j-2]...s[i,i+1]。。因为容量只与短边有关
	SO...
	public int maxArea(int[] height) {
        int i = 0, j = height.length - 1, res = 0;
        while(i < j){
            res = height[i] < height[j] ? 
                Math.max(res, (j - i) * height[i++]): 
                Math.max(res, (j - i) * height[j--]); 
        }
        return res;
    }
	
2.26删除重复元素
	最开始的想法：遍历咯，用idx来标识放置的位置
	正儿八经的说还是双指针，i来标记放置的位置，j进行遍历
	public int removeDuplicates(int[] nums) {
		if (nums.length == 0) return 0;
		int i = 0;
		for (int j = 1; j < nums.length; j++) {
			if (nums[j] != nums[i]) {
				i++;
				nums[i] = nums[j];
			}
		}
		return i + 1;
	}
	
3.27移除元素
	还是双指针，快慢指针，i位置，j遍历
	public int removeElement(int[] nums, int val) {
		int i = 0;
		for (int j = 0; j < nums.length; j++) {
			if (nums[j] != val) {
				nums[i] = nums[j];
				i++;
			}
		}
		return i;
	}
	当删除元素较少时，没必要每个都进行copy的工作，采用交换的方式，与数组末尾进行交换，同时数组大小减一，这样子
	public int removeElement(int[] nums, int val) {
		int i = 0;
		int n = nums.length;
		while (i < n) {
			if (nums[i] == val) {
				nums[i] = nums[n - 1];
				// reduce array size by one
				n--;
			} else {
				i++;
			}
		}
		return n;
	}
	
4.下一个排列
	不管前面的数组是怎么样的，我们的核心是去找反过来的对号的形状，1 2 7 4 3 1，这种结构的，找到最后一个这种结构，确定 2  3的位置，交换，
	因为我们找到这种结构就保证了7之后一定是降序序列，下一个序列一定是增序，因此 2之后的元素反转
	public void nextPermutation(int[] nums) {
        if (nums == null || nums.length == 0) return;
        int firstIndex = -1;
		//貌似也只能倒过来找
        for (int i = nums.length - 2; i >= 0; i--) {
            if (nums[i] < nums[i + 1]) {
                firstIndex = i;
                break;
            }
        }
		//没有这种结构，说明完全降序，也就是最大序列，反过来就行
        if (firstIndex == -1) {
            reverse(nums, 0, nums.length - 1);
            return;
        }
        int secondIndex = -1;
		//找到3的位置，也就是最后一个大于2的元素，
        for (int i = nums.length - 1; i >= 0; i--) {
            if (nums[i] > nums[firstIndex]) {
                secondIndex = i;
                break;
            }
        }
		//交换后仍能保证2之后是降序排列
        swap(nums, firstIndex, secondIndex);
		//反转为升序即可
        reverse(nums, firstIndex + 1, nums.length - 1);
        return;

    }

    private void reverse(int[] nums, int i, int j) {
        while (i < j) {
            swap(nums, i++, j--);
        }
    }

    private void swap(int[] nums, int i, int i1) {
        int tmp = nums[i];
        nums[i] = nums[i1];
        nums[i1] = tmp;
    }


5.53 最大子序和
	找到具有最大和的连续子数组，并返回最大值
	1.暴力法，以当前元素为起点，找到对应的最大和
	2.动态规划，dp[i]表示以当前元素结尾的最大和，dp[i] = dp[i-1]>0?dp[i-1]+nums[i]:nums[i]
	public int maxSubArray(int[] nums) {
		//因为仅与前一个元素相关，因此使用sum来代替dp数组
		Integer sum = 0;
		Integer ans = nums[0];
		for(int num:nums){
			if(sum>0){
				sum+=num;
			}
			else{
				sum = num;
			}
			ans = Math.max(sum,ans);
		}
		return ans;
    }

6.54 螺旋矩阵
	m*n的矩阵，顺时针螺旋遍历
	上下左右的边界法，我们遍历过了就更新边界，一圈一圈来，更新边界时出现交叉，那么就结束  还是边写注释边写代码比较好。。。左右不分。。。
	public List<Integer> spiralOrder(int[][] matrix) {
		ArrayList<Integer> list = new ArrayList();
		if(matrix == null || matrix.length==0) return list;
		int u = 0;
		int d = matrix.length-1;
		int l = 0;
		int r = matrix[0].length-1;
		
		while(true){
			//右
			for(int i=l;i<=r;i++) list.add(matrix[u][i]);
			//更新边界，判断交叉
			if(++u > d) break;
			//下
			for(int i=u;i<=d;i++) list.add(matrix[i][r]);
			//更新右边界
			if(--r <l) break;
			//左
			for(int i=r;i>=l;i--) list.add(matrix[d][i]);
			//更新下边界
			if(--d <u) break;
			//上
			for(int i=d;i>=u;i--) list.add(matrix[i][l]);
			//更新左边界
			if(++l > r) break;
		}
		return list;
        
    }