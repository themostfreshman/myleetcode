1.11 乘最多水的容器
	最开始的想法是 数组嘛，遍历就完事了，每个元素当key，判断当前key的最大值。。brute force
	双指针的核心是如何移动指针，也就是状态的剪枝，动谁呢，动小的那边，面积才有可能增大，
	s[i,j] 假设h[i]<h[j]，那么s[i+1,j] 一定大于s[i,j-1]、s[i,j-2]...s[i,i+1]。。因为容量只与短边有关
	SO...
	public int maxArea(int[] height) {
        int i = 0, j = height.length - 1, res = 0;
        while(i < j){
            res = height[i] < height[j] ? 
                Math.max(res, (j - i) * height[i++]): 
                Math.max(res, (j - i) * height[j--]); 
        }
        return res;
    }
	
2.26删除重复元素
	最开始的想法：遍历咯，用idx来标识放置的位置
	正儿八经的说还是双指针，i来标记放置的位置，j进行遍历
	public int removeDuplicates(int[] nums) {
		if (nums.length == 0) return 0;
		int i = 0;
		for (int j = 1; j < nums.length; j++) {
			if (nums[j] != nums[i]) {
				i++;
				nums[i] = nums[j];
			}
		}
		return i + 1;
	}
	
3.27移除元素
	还是双指针，快慢指针，i位置，j遍历
	public int removeElement(int[] nums, int val) {
		int i = 0;
		for (int j = 0; j < nums.length; j++) {
			if (nums[j] != val) {
				nums[i] = nums[j];
				i++;
			}
		}
		return i;
	}
	当删除元素较少时，没必要每个都进行copy的工作，采用交换的方式，与数组末尾进行交换，同时数组大小减一，这样子
	public int removeElement(int[] nums, int val) {
		int i = 0;
		int n = nums.length;
		while (i < n) {
			if (nums[i] == val) {
				nums[i] = nums[n - 1];
				// reduce array size by one
				n--;
			} else {
				i++;
			}
		}
		return n;
	}
	
4.下一个排列
	不管前面的数组是怎么样的，我们的核心是去找反过来的对号的形状，1 2 7 4 3 1，这种结构的，找到最后一个这种结构，确定 2  3的位置，交换，
	因为我们找到这种结构就保证了7之后一定是降序序列，下一个序列一定是增序，因此 2之后的元素反转
	public void nextPermutation(int[] nums) {
        if (nums == null || nums.length == 0) return;
        int firstIndex = -1;
		//貌似也只能倒过来找
        for (int i = nums.length - 2; i >= 0; i--) {
            if (nums[i] < nums[i + 1]) {
                firstIndex = i;
                break;
            }
        }
		//没有这种结构，说明完全降序，也就是最大序列，反过来就行
        if (firstIndex == -1) {
            reverse(nums, 0, nums.length - 1);
            return;
        }
        int secondIndex = -1;
		//找到3的位置，也就是最后一个大于2的元素，
        for (int i = nums.length - 1; i >= 0; i--) {
            if (nums[i] > nums[firstIndex]) {
                secondIndex = i;
                break;
            }
        }
		//交换后仍能保证2之后是降序排列
        swap(nums, firstIndex, secondIndex);
		//反转为升序即可
        reverse(nums, firstIndex + 1, nums.length - 1);
        return;

    }

    private void reverse(int[] nums, int i, int j) {
        while (i < j) {
            swap(nums, i++, j--);
        }
    }

    private void swap(int[] nums, int i, int i1) {
        int tmp = nums[i];
        nums[i] = nums[i1];
        nums[i1] = tmp;
    }




