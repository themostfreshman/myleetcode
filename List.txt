1.11 乘最多水的容器
	最开始的想法是 数组嘛，遍历就完事了，每个元素当key，判断当前key的最大值。。brute force
	双指针的核心是如何移动指针，也就是状态的剪枝，动谁呢，动小的那边，面积才有可能增大，
	s[i,j] 假设h[i]<h[j]，那么s[i+1,j] 一定大于s[i,j-1]、s[i,j-2]...s[i,i+1]。。因为容量只与短边有关
	SO...
	public int maxArea(int[] height) {
        int i = 0, j = height.length - 1, res = 0;
        while(i < j){
            res = height[i] < height[j] ? 
                Math.max(res, (j - i) * height[i++]): 
                Math.max(res, (j - i) * height[j--]); 
        }
        return res;
    }
	
2.26删除重复元素
	最开始的想法：遍历咯，用idx来标识放置的位置
	正儿八经的说还是双指针，i来标记放置的位置，j进行遍历
	public int removeDuplicates(int[] nums) {
		if (nums.length == 0) return 0;
		int i = 0;
		for (int j = 1; j < nums.length; j++) {
			if (nums[j] != nums[i]) {
				i++;
				nums[i] = nums[j];
			}
		}
		return i + 1;
	}
	
3.27移除元素
	还是双指针，快慢指针，i位置，j遍历
	public int removeElement(int[] nums, int val) {
		int i = 0;
		for (int j = 0; j < nums.length; j++) {
			if (nums[j] != val) {
				nums[i] = nums[j];
				i++;
			}
		}
		return i;
	}
	当删除元素较少时，没必要每个都进行copy的工作，采用交换的方式，与数组末尾进行交换，同时数组大小减一，这样子
	public int removeElement(int[] nums, int val) {
		int i = 0;
		int n = nums.length;
		while (i < n) {
			if (nums[i] == val) {
				nums[i] = nums[n - 1];
				// reduce array size by one
				n--;
			} else {
				i++;
			}
		}
		return n;
	}
	
4.下一个排列
	不管前面的数组是怎么样的，我们的核心是去找反过来的对号的形状，1 2 7 4 3 1，这种结构的，找到最后一个这种结构，确定 2  3的位置，交换，
	因为我们找到这种结构就保证了7之后一定是降序序列，下一个序列一定是增序，因此 2之后的元素反转
	public void nextPermutation(int[] nums) {
        if (nums == null || nums.length == 0) return;
        int firstIndex = -1;
		//貌似也只能倒过来找
        for (int i = nums.length - 2; i >= 0; i--) {
            if (nums[i] < nums[i + 1]) {
                firstIndex = i;
                break;
            }
        }
		//没有这种结构，说明完全降序，也就是最大序列，反过来就行
        if (firstIndex == -1) {
            reverse(nums, 0, nums.length - 1);
            return;
        }
        int secondIndex = -1;
		//找到3的位置，也就是最后一个大于2的元素，
        for (int i = nums.length - 1; i >= 0; i--) {
            if (nums[i] > nums[firstIndex]) {
                secondIndex = i;
                break;
            }
        }
		//交换后仍能保证2之后是降序排列
        swap(nums, firstIndex, secondIndex);
		//反转为升序即可
        reverse(nums, firstIndex + 1, nums.length - 1);
        return;

    }

    private void reverse(int[] nums, int i, int j) {
        while (i < j) {
            swap(nums, i++, j--);
        }
    }

    private void swap(int[] nums, int i, int i1) {
        int tmp = nums[i];
        nums[i] = nums[i1];
        nums[i1] = tmp;
    }


5.53 最大子序和
	找到具有最大和的连续子数组，并返回最大值
	1.暴力法，以当前元素为起点，找到对应的最大和
	2.动态规划，dp[i]表示以当前元素结尾的最大和，dp[i] = dp[i-1]>0?dp[i-1]+nums[i]:nums[i]
	public int maxSubArray(int[] nums) {
		//因为仅与前一个元素相关，因此使用sum来代替dp数组
		Integer sum = 0;
		Integer ans = nums[0];
		for(int num:nums){
			if(sum>0){
				sum+=num;
			}
			else{
				sum = num;
			}
			ans = Math.max(sum,ans);
		}
		return ans;
    }

6.54 螺旋矩阵
	m*n的矩阵，顺时针螺旋遍历
	上下左右的边界法，我们遍历过了就更新边界，一圈一圈来，更新边界时出现交叉，那么就结束  还是边写注释边写代码比较好。。。左右不分。。。
	public List<Integer> spiralOrder(int[][] matrix) {
		ArrayList<Integer> list = new ArrayList();
		if(matrix == null || matrix.length==0) return list;
		int u = 0;
		int d = matrix.length-1;
		int l = 0;
		int r = matrix[0].length-1;
		
		while(true){
			//右
			for(int i=l;i<=r;i++) list.add(matrix[u][i]);
			//更新边界，判断交叉
			if(++u > d) break;
			//下
			for(int i=u;i<=d;i++) list.add(matrix[i][r]);
			//更新右边界
			if(--r <l) break;
			//左
			for(int i=r;i>=l;i--) list.add(matrix[d][i]);
			//更新下边界
			if(--d <u) break;
			//上
			for(int i=d;i>=u;i--) list.add(matrix[i][l]);
			//更新左边界
			if(++l > r) break;
		}
		return list;
        
    }
	
7.55跳跃游戏
	之前做过2，要求的是跳跃的最小次数，这次是判断能不能到
	思路一样，判断当前点所能到达的最大边界，并判断边界内的各点所能到达的最远距离，然后更新边界
	public boolean canJump(int[] nums) {
		int end=0;
		for(int i=0;i<nums.length;i++){
			if(i>end) return false;
			end = Math.max(end,nums[i]+i);
		}
		return true;     
    }
	
	
8.56合并区间
	传入的参数数组是么的顺序的，因此需要以各元素的首元素进行排序，排完序然后呢，合并，[a,b] [c,d] 当b>c时需要合并，咋合并呢，左边界a确定，右边界为max(b,d)
	    public int[][] merge(int[][] intervals) {
        List<int[]> res = new ArrayList<>();
        if (intervals.length == 0 || intervals == null) return res.toArray(new int[0][]);
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        int i = 0;
        while (i < intervals.length) {
            int left = intervals[i][0];
            int right = intervals[i][1];
            while (i < intervals.length - 1 && intervals[i + 1][0] <= right) {
                i++;
                right = Math.max(right, intervals[i][1]);
            }
            res.add(new int[]{left, right});
            i++;
        }
        return res.toArray(new int[0][]);
    }
	需要注意的地方
	1.return res.toArray(new int[0][]);  参数意味着不指定行、行自动填充，如果为new int[4][], 即使结果为[[1,6],[8,10],[15,18]]， 也会强制输出[[1,6],[8,10],[15,18],null]，即不足行null补充
	2.Arrays.sort(intervals, (a, b) -> a[0] - b[0]);  lambda表达式写的comparator对象
	
9.57 插入区间  其实和56蛮像的，  先把插入区间的左半部分扔进结果数组([a,b] [c,d] c>b)  ,然后存在合并的情况([a,b],[c,d] b>c)，如果合并，使用合并的区间继续判断(使用temp数组来完成)
	之后把左边的区间扔进结果数组
	public int[][] insert(int[][] intervals, int[] newInterval) {
       List<int[]> res = new ArrayList<>();
        int i = 0;
		//左
        while (i < intervals.length && newInterval[0] > intervals[i][1]) {
            res.add(intervals[i]);
            i++;
        }
		//合并
        int[] tmp = new int[]{newInterval[0], newInterval[1]};
        while (i < intervals.length && newInterval[1] >= intervals[i][0]) {
            tmp[0] = Math.min(tmp[0], intervals[i][0]);
            tmp[1] = Math.max(tmp[1], intervals[i][1]);
            i++;
        }
        res.add(tmp);
		//右
        while (i < intervals.length) {
            res.add(intervals[i]);
            i++;
        }
        return res.toArray(new int[0][]); 
    }
	
	
10.59 螺旋矩阵2 和54很像，采取预设的边界进行模拟
    public int[][] generateMatrix(int n) {
        int l = 0, r = n - 1, t = 0, b = n - 1;
        int[][] mat = new int[n][n];
        int num = 1, tar = n * n;
        while(num <= tar){
            for(int i = l; i <= r; i++) mat[t][i] = num++; // left to right.
            t++;
            for(int i = t; i <= b; i++) mat[i][r] = num++; // top to bottom.
            r--;
            for(int i = r; i >= l; i--) mat[b][i] = num++; // right to left.
            b--;
            for(int i = b; i >= t; i--) mat[i][l] = num++; // bottom to top.
            l++;
        }
        return mat;
    }

11.62.不同路径 
	典型的动态规划题。。。好牛逼啊。。。。
	1.组合数学，机器人从start 到 end 总共要走 m-1+n-1=m+n-2步，然后呢，c(m-1,m+n-2)就完事了
	2.动态规划  dp[i][j]为到达当前位置所有的路径 dp[i][j]=dp[i-1][j]+dp[i][j-1]  i==0||j==0时dp=1;
		public int uniquePaths(int m, int n) {
			int[][] dp = new int[m][n];        
			for (int i = 0; i < m; i++) {
				for (int j = 0; j < n; j++) {
					if (i == 0 || j == 0)
						dp[i][j] = 1;
					else {
						dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
					}
				}
			}
			return dp[m - 1][n - 1];        
		}
	2.1优化空间
		dp仅与当前行与前一行相关，so
		    public int uniquePaths(int m, int n) {
        int[] pre = new int[n];
        int[] cur = new int[n];
        Arrays.fill(pre, 1);
        Arrays.fill(cur,1);
        for (int i = 1; i < m;i++){
            for (int j = 1; j < n; j++){
                cur[j] = cur[j-1] + pre[j];
            }
            pre = cur.clone();
        }
        return pre[n-1]; 
    }
	2.2进一步优化，cur本身就存有前一行的数值，因此cur[j]=cur[j-1]+cur[j]
	public int uniquePaths(int m, int n) {
        int[] cur = new int[n];
        Arrays.fill(cur,1);
        for (int i = 1; i < m;i++){
            for (int j = 1; j < n; j++){
                cur[j] += cur[j-1] ;
            }
        }
        return cur[n-1];
    }

12.63.不同路径2
	与上题相比增加了障碍，因此需要对第一行和第一列做特殊判断，而从[1,1]开始，如上，遇到1 dp为0即可   这里把原数组作为dp数组
	    public int uniquePathsWithObstacles(int[][] obstacleGrid) {

        int R = obstacleGrid.length;
        int C = obstacleGrid[0].length;

        // If the starting cell has an obstacle, then simply return as there would be
        // no paths to the destination.
        if (obstacleGrid[0][0] == 1) {
            return 0;
        }

        // Number of ways of reaching the starting cell = 1.
        obstacleGrid[0][0] = 1;

        // Filling the values for the first column
        for (int i = 1; i < R; i++) {
            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i - 1][0] == 1) ? 1 : 0;
        }

        // Filling the values for the first row
        for (int i = 1; i < C; i++) {
            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i - 1] == 1) ? 1 : 0;
        }

        // Starting from cell(1,1) fill up the values
        // No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]
        // i.e. From above and left.
        for (int i = 1; i < R; i++) {
            for (int j = 1; j < C; j++) {
                if (obstacleGrid[i][j] == 0) {
                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
                } else {
                    obstacleGrid[i][j] = 0;
                }
            }
        }

        // Return value stored in rightmost bottommost cell. That is the destination.
        return obstacleGrid[R - 1][C - 1];
    }
	
	同样可以使用上面的优化方法对该题进行优化  dp的取值原因
	这里没有对第一行进行单独判断，因为第一行除[1,1]外初始化为0，dp[j]+=dp[j-1],第一个1出现后可以保证后面全为0。
	第一列的话，就使用上一列的数值即可。
	public int uniquePathsWithObstacles(int[][] grid) {
        int[] dp = new int[grid[0].length];
        dp[0]=1;
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1){
                    dp[j]=0;
                    continue;
                }
                if(j>0)
                    dp[j]+=dp[j-1];
            }
        }
        return dp[dp.length-1];
    }
13.64.最小路径和
	还是标准的动态规划解法，改改上面的代码就好
	空间优化好像不行
	public int minPathSum(int[][] grid) {
        for(int i = 0; i < grid.length; i++) {
            for(int j = 0; j < grid[0].length; j++) {
                if(i == 0 && j == 0) continue;
                else if(i == 0)  grid[i][j] = grid[i][j - 1] + grid[i][j];
                else if(j == 0)  grid[i][j] = grid[i - 1][j] + grid[i][j];
                else grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];
            }
        }
        return grid[grid.length - 1][grid[0].length - 1];
    }
	
14.66.加一
	看清楚题哈，返回的还是数组，那么就倒着来，如果产生进位，就继续，如果遍历完还在产生进位，那就说明是999的情况，最后直接给个1000就可以了  length+1，首位赋1
	public int[] plusOne(int[] digits) {
        for (int i = digits.length - 1; i >= 0; i--) {
            digits[i]++;
            digits[i] = digits[i] % 10;
            if (digits[i] != 0) return digits;
        }
        digits = new int[digits.length + 1];
        digits[0] = 1;
        return digits;
    }
	
15.矩阵置零
	么的意思  两次遍历。第一次找行列，第二次置零 
	public void setZeroes(int[][] matrix) {
        Set<Integer> row_zero = new HashSet<>();
        Set<Integer> col_zero = new HashSet<>();
        int row = matrix.length;
        int col = matrix[0].length;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (matrix[i][j] == 0) {
                    row_zero.add(i);
                    col_zero.add(j);
                }
            }
        }
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (row_zero.contains(i) || col_zero.contains(j)) matrix[i][j] = 0;
            }
        }  
    }
	
	不过这里的要求是空间复杂度o(1)，所以上面的并不符合
	那么我们使用第一行与第一列来作为标记位，这样的话需要提前判断第一行与第一列是否包含零，最后再清空一下
	public void setZeroes(int[][] matrix) {
        int row = matrix.length;
        int col = matrix[0].length;
        boolean row0_flag = false;
        boolean col0_flag = false;
        // 第一行是否有零
        for (int j = 0; j < col; j++) {
            if (matrix[0][j] == 0) {
                row0_flag = true;
                break;
            }
        }
        // 第一列是否有零
        for (int i = 0; i < row; i++) {
            if (matrix[i][0] == 0) {
                col0_flag = true;
                break;
            }
        }
        // 把第一行第一列作为标志位
        for (int i = 1; i < row; i++) {
            for (int j = 1; j < col; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = matrix[0][j] = 0;
                }
            }
        }
        // 置0
        for (int i = 1; i < row; i++) {
            for (int j = 1; j < col; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }
        if (row0_flag) {
            for (int j = 0; j < col; j++) {
                matrix[0][j] = 0;
            }
        }
        if (col0_flag) {
            for (int i = 0; i < row; i++) {
                matrix[i][0] = 0;
            }
        } 
    }

16.搜索二维数组
	因为完全有序的特性，这里我们转为一维数组并使用二分法来查找
		1.咋转一维数组呢，一维数组共有row*col个数组，那么一维数组的元素坐标j转为二维数组则为[j/col][j%col]
		2.二分法，这里搜索区间定位[0,row*col）左闭右开，if(mid<target) left=mid+1;else right=mid;	
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) return false;
        int row = matrix.length;
        int col = matrix[0].length;
        int left = 0;
        int right = row * col;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (matrix[mid / col][mid % col] < target) left = mid + 1;
            else right = mid;
        }
        return (left < row * col && matrix[left / col][left % col] == target); 
    }
